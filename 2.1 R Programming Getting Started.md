## R Programming Background, Getting Started, and Nuts & Bolts

### Working directory and first scripts

* getwd() - this gets working directory
* this is where data gets read from or written to etc, so this is where R looks
* You can change it in the file menu "changedir" - I found this in "session"
* setwd("filepath") also sets directory in code
* dir() - this gets folder and files in a directory
* I set up my working directory in e.g. C:\Users\ri080230\Documents\Projects\DataScienceCoursera
* read.data("mycsv.csv") example to read data
* File > New File > R Script (to create new script)
* myfunction <- function(){
      x <- rnorm(100)
      mean(x)
}
* Ensure that there are no line spaces in the function
* Copy and paste the function into your console and press enter
* When you press ls() you will see the function ready to use

###Overview and History of R

* Derivative of S language
* R runs on pretty much anything, including the PS3!
* R stores stuff in physical memory so you need enough of this
* Base packages and recommended packages - come from CRAN
* There are a load more packages on CRAN and bioconductor project (genomic and biological) https://www.bioconductor.org/
* Documentation here: https://cran.r-project.org/
* https://www.r-project.org/doc/bib/R-books.html

##R Console Input and Evaluation
* <- assigns value to variable (vector)
* e.g. > x <- 5
* > x
* [1] 5 - the [1] is the first element of the vector
* # for comment
* x <- 1:20 #Creates a sequence

##R Data Types: Objects and attributes
* character, numeric, integer, complex, logical (bool)
* vector(class, length) ##Basic object, must be same class (datatypes), one exception is list
* 1 #would explicitly be numeric
* 1L #would explicitly be integer
* Inf #infinity
* NaN #Not a number e.g. 0/0 or missing value
* attributes() #names, dimnames, dimensions, class, length, UDF

##R Data Types: Vectors and Lists
* c(variable1, variable2) ##c is like concatenate so can make a vector
* x <- c(0.5,0.6) ##creates a numeric vector with 0.5 and 0.6
* x <- vector("numeric", length=10) #sets x to be ten zeroes as zero is default for numeric
* When mix data types does like SQL and finds lowest possible data type can use (numeric becomes text etc)
* as.numeric(x) #You can explicitly convert to data type using as.
* NA values will be return if try and convert what cant be converted
* x <- list(1, "a", TRUE, 1+4i) ##list can have mixed types

##R Data Types: Matrices
* Special type of vector, have a dimension attribute
* m <- matrix(nrow=2,ncol=3)
* dim(m) #returns number of columns and rows
* attributes(m) #returns the dim, as is first attribute
* m <- matrix(1:6,nrow=2,ncol=3)
* m <- 1:10 ##creates vector
* dim(m) <- c(2,5) ##creates matrix with 2 rows and 5 columns
* cbind(x,y) # column bind to create matrix
* rbind(x,y) # row bind to create matrix

##R Data Types: factors
* Categorical vectors (Male/female or ordererd - rank)
* x <- factor(c("yes","yes","no","yes","no")) ##create a factor
* table(x) #aggregates the factor
* unclass(x) #returns integer representation of factor
* attr(,"levels") #levels attribute of factor
* x <- factor(c("yes","yes","no","yes","no"), levels = c("yes","no")) ##create a factor explicitly stating order, firts one is then baseline

##R Data Types: Missing Values
* is.na() #test for NA - missing values, NA have a class too (numeric NA, char NA)
* is.nan() #test for NaN - maths, NaN is an NA but NA is not a NaN
* is.na(1,NA,3) ##will only return true for NA

##R Data Types: Data Frames
* Store tabular data - difference classes in each column unlike matrices
* row.names 
* read.table() , read.csv() #create data frame
* data.matrix() #convert to matrix and will coerce to same datatype
* x <- data.frame(foo= 1;4,bar=c(T,T,F,F)) #create data frame
* nrow(x) #rows
* ncol(x) #columns

##R Data Types: Names Attribute
* x <- 1:3
* names(x) <- c("foo","bar","norf") #applies names
* names(x) #gets names
* x <- list(a=1,b=2,c=3) #list names
* m <- matrix(1:4, nrow=2,ncol=2) #matrix 
* dimnames(m) <- list(c("a","b"),c("c","d")) #matrix names

##Reading Tabular Data
* read.table, write.table #most common
* file, header, sep, colClasses, nrows, comment.char, skip, stringAsFactors #arguments for read.table
* data <- read.table("foo.txt")
* providing arguments up front can speed it up
* read.csv, write.csv 
* same as read.table except default separator is comma
* readLines, writelines #lines of text file
* source, dump
* dget, dput
* load, save #binary objects
* unserialize, serialize #binary objects

##Reading Large Tables
* read help page for read.table
* do memory calculations (amount of RAM you have) and see if can fit data, know your system
* need twice as much RAM as data
* read in first 100 rows and get class metadata
* initial <- read.tabe("datatable.txt", nrows=100)
* classes <-sapply(initial,class)
* tabAll <- read.table("datatable,txt", colClasses= classes)

##Textual Data Formats
* dumping, source #dump can be used on multiple objects
* dputing, dget
* preserve metadata and carry with it
* format not space efficient
* ###dput & dget example
* > y <- data.frame(a=1,b="a")
* > dput(y,file ="y.r") #moves to file
* > new.y <- dget("y.r") #gets it back
* > new.y #show
* ###dump & source example
* > X <- "foo" #create x
* > y <- data.frame(a=1,b="a") #create y
* > dump(c("x","y"), file="data.R") #dump x &y to file
* > rm(x,y) #remove x and y
* > source("data.R") #bring x and y back
* > y #shows y
* > x #shows x

##Interfaces to the Outside World
* file, gzfile, bzfile, url
* str(file) #show arguments for file
* con <- file ("foo.txt", "r") #r signifies reading
* data <- read.csv(con)
* close(con)
* same as read.csv(file)
* readLines(con,10) #first 10 rows
* from a url...
* con <- url("http://www.jhsph.edu", "r") #creates connection
* x <- readLines(con) #reads into x
* head(x) #shows header row of x

##Subsetting R Objects
* Subsetting is filtering
* [  #same class
* [[ #list or data frame
* $ operators #list or data frame by name
* x <- c("a","b","c","c","d","a") 
* x[1] #subset 
* x[2] #subset
* x[1:4] #subset
* x[x > "a"] #subset logical
* u <- x > "a" #subset into u
* x[u] #returns logic matching u

##Subsetting Lists
* x <- list(foo = 1:4, bar=0.6)
* x[1] #single [ returns list as that is what is getting
* x[[1]] #double [[ returns just sequence, not a list
* x$bar #gives element that is bar
* x[["bar"]] #brings back same as above
* x["bar"] #brings back list that is bar
* x <- list(foo = 1:4, bar=0.6, baz="hello")
* x[c(1,3)] #returns elements foo and baz, which are lists
* if want to use a computed variable have to use [[ not $
* name <- "foo"
* x <- list(foo = 1:4, bar=0.6, baz="hello")
* x[[name]] #works from variable
* x$name #doesnt work as looks for element called name, needs literals
* x$foo #works direct
* [[ can take an int sequence
* x <- list(a=list(10,12,14),b=c(3.14,2.81))
* x[[c(1,3)]] #14, as third element of first element
* x[[1]][[3]] #14, same as above
* x[[c(2,1)]] #31.4, as first element of second element

##Subsetting Matrices
* x <- matrix(1:6,2,3) ##values 1to 6, 2 rows, 3 columns
* x[1,2] #3, as first row second column
* x[2,1] #2 as first column second row
* x[1,] #first row all, Indices can be missing in matrix
* x[,2] #second column  all, Indices can be missing in matrix
* if only one element return returns factor and not a 1x1 matrix, can turn off using drop=false 
* Same as if bring one row or column back, brings a vector not matrix, again can turn off drop=false
* x[,2,drop=false] #example of ensuring matrix back
* 



